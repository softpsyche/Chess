using Arcesoft.Chess.Models;
using Arcesoft.Chess.Models.Internal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Arcesoft.Chess.Implementation
{
    internal class ThreatProvider
    {
        /// <summary>
        /// Finds all threats for the given player and board. Finds all the opposing players
        /// pieces and calculates the threats against the passed in player.
        /// </summary>
        /// <param name="board"></param>
        /// <param name="player"></param>
        /// <returns></returns>
        public ThreatMatrix FindThreatsForPlayer(Board board, Player player)
        {
            //find all opposing pieces
            var opposingPlayer = player.OpposingPlayer();
            var playerKingLocation = board.GetKingsLocation(player);
            var opposingPieceLocations = board.FindPlayerPieceLocations(opposingPlayer);

            ThreatMatrix threatMatrix = new ThreatMatrix();

            opposingPieceLocations
                .ForEach(a => AddThreats(board, player, playerKingLocation, a, threatMatrix));

            return threatMatrix;
        }
        /// <summary>
        /// Finds all threats generated by the given piece at the specified board location.
        /// returns an empty dictionary if the location does not contain a chess piece.
        /// </summary>
        /// <param name="board"></param>
        /// <param name="boardLocation"></param>
        /// <returns></returns>
        public ThreatMatrix FindThreatsForBoardLocation(Board board, BoardLocation boardLocation)
        {
            ThreatMatrix threatMatrix = new ThreatMatrix();
            var chessPiece = board[boardLocation];
            var player = chessPiece.Player().OpposingPlayer();
            var opposingPlayer = chessPiece.Player();

            if (chessPiece != ChessPiece.None)
            {
                AddThreats(board, player, board.GetKingsLocation(player), boardLocation, threatMatrix);
            }

            return threatMatrix;
        }


        private void AddThreats(
            Board board,
            Player player,
            BoardLocation playerKingLocation,
            BoardLocation opposingPieceBoardLocation,
            ThreatMatrix threatMatrix)
        {
            var chessPiece = board[opposingPieceBoardLocation];

            switch (chessPiece)
            {
                case ChessPiece.BlackPawn:
                case ChessPiece.WhitePawn:
                    AddPawnThreats(board, player, playerKingLocation, opposingPieceBoardLocation, threatMatrix);
                    break;
                case ChessPiece.BlackRook:
                case ChessPiece.WhiteRook:
                    AddRookThreats(board, player, playerKingLocation, opposingPieceBoardLocation, threatMatrix);
                    break;
                case ChessPiece.BlackKnight:
                case ChessPiece.WhiteKnight:
                    AddKnightThreats(board, player, playerKingLocation, opposingPieceBoardLocation, threatMatrix);
                    break;
                case ChessPiece.BlackBishop:
                case ChessPiece.WhiteBishop:
                    AddBishopThreats(board, player, playerKingLocation, opposingPieceBoardLocation, threatMatrix);
                    break;
                case ChessPiece.BlackQueen:
                case ChessPiece.WhiteQueen:
                    //queen is rook and bishop so we can cheat it
                    AddRookThreats(board, player, playerKingLocation, opposingPieceBoardLocation, threatMatrix);
                    AddBishopThreats(board, player, playerKingLocation, opposingPieceBoardLocation, threatMatrix);
                    break;
                case ChessPiece.BlackKing:
                case ChessPiece.WhiteKing:
                    AddKingThreats(board, player,playerKingLocation, opposingPieceBoardLocation, threatMatrix);
                    break;
                default:
                    throw new Exception($"Unexpected chessPiece value {opposingPieceBoardLocation.ToString()}");
            }
        }

        private void AddPawnThreats(
            Board board,
            Player player,
            BoardLocation playerKingLocation,
            BoardLocation opposingPieceBoardLocation,
            ThreatMatrix threatMatrix)
        {
            //PGN format for the board
            //    A  B  C  D  E  F  G  H
            //8:| 7|15|23|31|39|47|55|63|
            //7:| 6|14|22|30|38|46|54|62|
            //6:| 5|13|21|29|37|45|53|61|
            //5:| 4|12|20|28|36|44|52|60|
            //4:| 3|11|19|27|35|43|51|59|
            //3:| 2|10|18|26|34|42|50|58|
            //2:| 1| 9|17|25|33|41|49|57|
            //1:| 0| 8|16|24|32|40|48|56|

            BoardLocation?[] moves = new BoardLocation?[2];
            if (player == Player.White)
            {
                //then we are worried about the black guys pieces
                moves[0] = opposingPieceBoardLocation.SouthEast();
                moves[1] = opposingPieceBoardLocation.SouthWest();
            }
            else
            {
                moves[0] = opposingPieceBoardLocation.NorthEast();
                moves[1] = opposingPieceBoardLocation.NorthWest();
            }

            moves
                .Where(a => a.HasValue)
                .ForEach(a => AddThreat(threatMatrix, playerKingLocation, opposingPieceBoardLocation, a.Value, ThreatDirection.Direct));
        }

        private void AddKnightThreats(
            Board board,
            Player player,
            BoardLocation playerKingLocation,
            BoardLocation opposingPieceBoardLocation,
            ThreatMatrix threatMatrix)
        {
            //PGN format for the board
            //    A  B  C  D  E  F  G  H
            //8:| 7|15|23|31|39|47|55|63|
            //7:| 6|  |22|  |38|46|54|62|
            //6:|  |13|21|29|  |45|53|61|
            //5:| 4|12|20|28|36|44|52|60|
            //4:|  |11|19|27|  |43|51|59|
            //3:| 2|  |18|  |34|42|50|58|
            //2:| 1| 9|17|25|33|41|49|57|
            //1:| 0| 8|16|24|32|40|48|56|

            //A knights move from postion 20.
            //-17
            //-15
            //-10
            //-6
            //+17
            //+15
            //+10
            //+6

            List<BoardLocation> possibleMoves = new List<BoardLocation>();
            var knightLocation = opposingPieceBoardLocation.ToByte();

            //same column
            var leftDown = knightLocation - 17;
            var leftUp = knightLocation - 15;
            //same row
            var upLeft = knightLocation - 6;
            var upRight = knightLocation + 10;
            //same column
            var rightUp = knightLocation + 17;
            var rightDown = knightLocation + 15;
            //same row
            var downLeft = knightLocation - 10;
            var downRight = knightLocation + 6;

            if ((leftDown >= 0) &&
                ((knightLocation / 8) - (leftDown / 8) == 2))
            {
                possibleMoves.Add((BoardLocation)leftDown);
            }
            if ((leftUp >= 0) &&
                ((knightLocation / 8) - (leftUp / 8) == 2))
            {
                possibleMoves.Add((BoardLocation)leftUp);
            }

            if ((upLeft >= 0) &&
                ((knightLocation / 8) - (upLeft / 8) == 1))
            {
                possibleMoves.Add((BoardLocation)upLeft);
            }
            if ((downLeft >= 0) &&
                ((knightLocation / 8) - (downLeft / 8) == 1))
            {
                possibleMoves.Add((BoardLocation)downLeft);
            }

            if ((upRight < Constants.BoardSize) &&
                ((knightLocation / 8) - (upRight / 8) == -1))
            {
                possibleMoves.Add((BoardLocation)upRight);
            }
            if ((downRight < Constants.BoardSize) &&
                ((knightLocation / 8) - (downRight / 8) == -1))
            {
                possibleMoves.Add((BoardLocation)downRight);
            }

            if ((rightUp < Constants.BoardSize) &&
                ((knightLocation / 8) - (rightUp / 8) == -2))
            {
                possibleMoves.Add((BoardLocation)rightUp);
            }
            if ((rightDown < Constants.BoardSize) &&
                ((knightLocation / 8) - (rightDown / 8) == -2))
            {
                possibleMoves.Add((BoardLocation)rightDown);
            }

            possibleMoves
                .ForEach(a => AddThreat(threatMatrix,playerKingLocation, opposingPieceBoardLocation, a, ThreatDirection.Direct));
        }

        private void AddKingThreats(
            Board board,
            Player player,
            BoardLocation playerKingLocation,
            BoardLocation opposingPieceBoardLocation,
            ThreatMatrix threatMatrix)
        {
            opposingPieceBoardLocation
                .Neighbors()
                .ForEach(a => AddThreat(threatMatrix, playerKingLocation, opposingPieceBoardLocation, a, ThreatDirection.Direct));
        }

        private void AddRookThreats(
            Board board,
            Player player,
            BoardLocation playerKingLocation,
            BoardLocation opposingPieceBoardLocation,
            ThreatMatrix threatMatrix)
        {
            //horizontal
            AddDirectionalThreats(board, player, playerKingLocation, opposingPieceBoardLocation, Direction.East, threatMatrix);
            AddDirectionalThreats(board, player, playerKingLocation, opposingPieceBoardLocation, Direction.West, threatMatrix);

            //vertical
            AddDirectionalThreats(board, player, playerKingLocation, opposingPieceBoardLocation, Direction.North, threatMatrix);
            AddDirectionalThreats(board, player, playerKingLocation, opposingPieceBoardLocation, Direction.South, threatMatrix);
        }

        private void AddBishopThreats(
            Board board,
            Player player,
            BoardLocation playerKingLocation,
            BoardLocation opposingPieceBoardLocation,
            ThreatMatrix threatMatrix)
        {
            //slope
            AddDirectionalThreats(board, player, playerKingLocation, opposingPieceBoardLocation, Direction.NorthWest, threatMatrix);
            AddDirectionalThreats(board, player, playerKingLocation, opposingPieceBoardLocation, Direction.SouthEast, threatMatrix);

            //grade
            AddDirectionalThreats(board, player, playerKingLocation, opposingPieceBoardLocation, Direction.SouthWest, threatMatrix);
            AddDirectionalThreats(board, player, playerKingLocation, opposingPieceBoardLocation, Direction.NorthEast, threatMatrix);
        }

        private void AddDirectionalThreats(
            Board board,
            Player player,
            BoardLocation playerKingLocation,
            BoardLocation opposingPieceBoardLocation,
            Direction direction,
            ThreatMatrix threatMatrix)
        {
            //get the next square in the given direction
            BoardLocation? currentLocation = opposingPieceBoardLocation.Neighbor(direction);

            //for directional threats the king might be pinned...
            var kingCouldBePinned = playerKingLocation.IsInGivenDirectionFrom(opposingPieceBoardLocation, direction);
            var threatDirection = direction.ToThreatDirection();

            while (currentLocation != null)
            {
                //get the piece
                var piece = board[currentLocation.Value];

                //as long as we are empty we can keep moving!
                if (piece == ChessPiece.None)
                {
                    //empty square, no pin possible
                    AddThreat(threatMatrix, playerKingLocation, opposingPieceBoardLocation, currentLocation.Value, threatDirection);
                }
                else
                {
                    ThreatDirection? pinDirection = null;

                    //our piece which MIGHT have a pin if our king is on the same directional vector..check for it
                    if ((piece.BelongsTo(player)) && 
                        (kingCouldBePinned) &&
                        PieceIsPinned(board, currentLocation.Value, playerKingLocation, direction))
                    {
                        pinDirection = direction.ToThreatDirection();
                    }

                    AddThreat(
                        threatMatrix,
                        playerKingLocation,
                        opposingPieceBoardLocation,
                        currentLocation.Value,
                        threatDirection,
                        pinDirection);

                    //NOTE: This is a hack, but its a domain hack. From a threat perspective, we can pretend
                    //that the enemy king is 'invisible'. This will allow long range threats to penetrate the king
                    //and proceed to any columns, rows, or diagonals he is on. This in turn will help us
                    //when determining the kings moves by making 'backing up' an invalid strategy for him.
                    //without this check, a king himself would demarcate the end of a long range threat (since a piece is like a stop)
                    //but THAT would create the problem of making it seem like the square behind him was 'safe'. For Example:
                    //   |  |  |  |  |         |  |  |  |  |
                    //   |  |WR|BK|  |  To=>   |  |WR|  |BK|  would be allowed
                    //   |  |  |  |  |         |  |  |  |  |
                    //Where it is kind of a hack is by treating the king as invisible it means the white rook is threatening
                    //'beyond' a piece. Theoretically, this would then also allow it to move into those spaces, in essence just
                    //'hoping over' the king. This would be a HUGE problem if not for the golden rule of chess that it is impossible
                    //to make a move that actually captures a king. The game literally ends as soon as a board state emerges where 
                    //a king is able to captured on the next turn. Not sure why this is, I am sure it harkens back to some 
                    //haughty rule about how 'ignoble' it would be to ever allow the capture of a royal.  
                    if (piece.IsKing(player) == false)
                    {
                        //short circuit search since we are done
                        break;
                    }
                }

                currentLocation = currentLocation.Neighbor(direction);
            }
        }

        private bool PieceIsPinned(Board board, BoardLocation piecesLocation, BoardLocation kingsLocation, Direction direction)
        {
            BoardLocation? currentLocation = piecesLocation.Neighbor(direction);

            while (currentLocation != null)
            {
                //get the piece
                var piece = board[currentLocation.Value];

                if (currentLocation == kingsLocation)
                {
                    return true;
                }
                else if (board[currentLocation.Value] != ChessPiece.None)
                {
                    break;
                }

                currentLocation = currentLocation.Neighbor(direction);
            }

            return false;
        }

        private void AddThreat(
            ThreatMatrix threatMatrix,
            BoardLocation playerKingLocation,
            BoardLocation threateningPieceLocation,
            BoardLocation boardLocationBeingThreatening,
            ThreatDirection direction,
            ThreatDirection? pin = null)
        {
            if (!threatMatrix.ContainsKey(boardLocationBeingThreatening))
            {
                threatMatrix.Add(boardLocationBeingThreatening, direction, pin);
            }
            else
            {
                //update the threat direction
                threatMatrix[boardLocationBeingThreatening].AddDirection(direction);

                //can only be pinned in one direction (since there is only one king)
                if (pin != null)
                {
                    threatMatrix[boardLocationBeingThreatening].AddPin(pin.Value);
                }
            }

            //if this is a king threat
            if (playerKingLocation == boardLocationBeingThreatening)
            {
                //we set the piece that is threatening the king here. Please note that it is possible more than one piece
                //is threatening the king but it is IMPOSSIBLE for a triple check to occur.
                var threat = threatMatrix[boardLocationBeingThreatening];
                if (threat.FirstPieceThreateningKingBoardLocation.HasValue)
                {
                    threat.SecondPieceThreateningKingBoardLocation = threateningPieceLocation;
                }
                else
                {
                    threat.FirstPieceThreateningKingBoardLocation = threateningPieceLocation;
                }
            }
        }
    }
}
